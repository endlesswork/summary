## 1. 背景
用户下单后，如果在设定时间（如 30 分钟）内未支付，需要自动取消订单并释放库存。  
要求：
- 高并发可用
- 取消动作可靠执行
- 保证库存与订单状态一致性

## 2. 方案分类

### 方案一：消息队列延迟消息
**实现思路**
- 下单时向 MQ（如 RabbitMQ 延迟队列、RocketMQ 延迟消息、Kafka 延迟功能）发送一条延迟消息，延迟时间 = 订单超时时间
- 消息到期后消费者收到，执行取消逻辑

**优点**
- 精度高（秒级）
- 不用扫描全表
- 分布式、可扩展性强

**缺点**
- 依赖 MQ 支持延迟消息
- MQ 消息可靠性、幂等性需要处理（防止重复取消）

**适用场景**
- 订单量大，对精度要求高（如秒杀、拼团）
- 已有稳定的 MQ 基础设施

### 方案二：Redis 延迟队列 / TTL Key 监听
**实现思路**
- 下单时 SET key order:{id} value ... EX 1800（30分钟过期）
- 使用 Redis Keyspace Notifications 监听 key 过期事件，触发取消逻辑
- 或者用**ZSET**存订单，到期时间为 score，轮询 ZSET 中到期的订单

**优点**
- 精度高
- Redis 性能强
- 不依赖 MQ

**缺点**
- Redis 过期事件通知需要单节点，集群需额外实现
- Redis 宕机可能丢失事件（需补偿机制）

**适用场景**
- 已经依赖 Redis
- 延迟任务量大但精度要求高

### 方案三：数据库定时任务扫描（批量轮询）
**实现思路**
- 订单表中保存 create_time / expire_time / status
- 定时任务（如 Quartz、XXL-JOB、Spring Schedule）每隔一段时间扫描：
- 对符合条件的订单执行取消逻辑（释放库存、通知用户）

**优点**
- 实现简单
- 易于维护
- 不依赖额外中间件

**缺点**
- 延迟精度取决于任务执行频率（可能延迟几分钟）
- 高并发场景下扫描压力大（需要分片扫描）