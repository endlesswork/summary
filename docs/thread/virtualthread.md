# 🌱 Java 虚拟线程（Virtual Thread）总结

## 一、什么是虚拟线程？

虚拟线程是 Java 19 引入的轻量级线程模型（Project Loom 的核心特性），**由 JVM 而不是操作系统管理调度**。
> **虚拟线程 = JVM 调度的可挂起线程，不绑定操作系统线程。**

## 二、核心特性

| 特性 | 描述 |
|------|------|
| 🧵 轻量级 | 内存占用极低，可创建百万级线程 |
| 🔁 非绑定平台线程 | 不长期绑定 OS 线程，可在多个平台线程之间调度 |
| 💤 阻塞非阻塞化 | 阻塞操作不会占用底层平台线程，由 JVM 挂起 |
| 🛠 与 Thread API 兼容 | 使用方式与传统线程一致 |
| ☂ 支持同步编程 | 同步代码也能高并发，无需复杂回调或异步框架 |

### ✅ 平台线程
- 每一个平台线程都对应一个操作系统线程（OS Thread）。
- 当你调用阻塞操作（比如 sleep()、read()、数据库查询）时：
	- 虽然会让出CPU资源；
	- 整个 OS 线程就会“挂在那里”等待结果返回；
	- 操作系统不会让这个线程干别的事情；
	- 即使 CPU 会调度其他线程，但这个线程资源就“浪费”在那里了。

### ✅ 虚拟线程
- 虚拟线程是由 JVM 自己调度 的线程，不直接绑定到 OS 线程。
- 当发生阻塞操作时（比如 sleep()）：
	- JVM 会检测这是可挂起点（suspendable），
	- 主动把虚拟线程挂起并移除出平台线程；
	- 平台线程被释放，立刻去执行其他虚拟线程	
## 三、运行机制

- **创建**：使用 `Thread.ofVirtual().start(...)` 创建；
- **调度**：由 JVM 用户态调度器管理；
- **挂起**：遇到阻塞点（sleep、IO）时被挂起，释放平台线程；
- **恢复**：等待完成后，重新分配平台线程继续执行。


## 四、与平台线程对比

| 对比项 | 平台线程（传统线程） | 虚拟线程 |
|--------|---------------------|----------|
| 是否绑定 OS Thread | ✅ 是 | ❌ 否（动态借用） |
| 创建开销 | 高（MB 级栈内存） | 极低（KB 级） |
| 阻塞行为 | 占用 OS 线程资源 | 挂起释放 OS 线程 |
| 并发能力 | 数千个线程 | 数十万、百万级线程 |
| 调度方式 | 操作系统（内核态） | JVM（用户态） |
| 适用场景 | 计算密集 | 高并发、IO密集型 |


## 五、示例代码

```java
public class Demo {
    public static void main(String[] args) {
        Thread.startVirtualThread(() -> {
            System.out.println("开始任务");
            try {
                Thread.sleep(1000); // 不阻塞平台线程
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("任务完成");
        });
    }
}
```
## 六、适用场景
- 高并发 Web 服务（Spring Boot + 虚拟线程）
- IO 密集任务：数据库、RPC、HTTP 调用
- 替代传统线程池异步方案

## 七、注意事项
- 虚拟线程 ≠ 异步编程，但能实现类似效果
- 并非所有阻塞操作都能挂起，需使用支持的 API（如 Loom 支持的类库）
- CPU 密集任务仍需控制虚拟线程数量，避免过度堆叠
