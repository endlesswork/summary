# 内核态和用户态
## 🧠 为什么会有内核态和用户态

> **为了系统的安全性、稳定性和资源隔离性，必须对程序的运行权限进行区分。**

如果用户程序可以随意访问硬件资源，会导致：
- 系统崩溃（比如访问非法内存）
- 数据泄露或被篡改
- 应用之间相互干扰

因此，现代操作系统将 CPU 的执行权限分为两种状态：

- **用户态（User Mode）**
- **内核态（Kernel Mode）**

## 二、内核态 vs 用户态 对比表

| 项目               | 用户态（User Mode） | 内核态（Kernel Mode） |
|--------------------|---------------------|------------------------|
| 权限等级           | 低                  | 高                     |
| 能否直接操作硬件   | ❌ 不可以           | ✅ 可以                |
| 能否访问内核内存   | ❌ 不可以           | ✅ 可以                |
| 程序示例           | 普通应用程序        | 操作系统内核代码       |
| 运行效率           | 高（更轻量）        | 较低（上下文复杂）     |


## 三、状态切换机制：系统调用（System Call）

用户态的程序在运行时 **无法直接访问硬件资源**（比如磁盘、内存、网卡），必须通过 **系统调用** 进入内核态，由操作系统代为处理。

### 🧭 状态切换流程（以 `read()` 系统调用为例）

```text
用户程序运行中（用户态）
        ↓
调用 read()（触发系统调用）
        ↓
切换到内核态，由操作系统处理读磁盘操作
        ↓
操作完成后，将结果返回给用户程序
        ↓
切换回用户态，继续执行剩余逻辑
```
## 四、 ✅ 为什么采用这种机制？

- 安全性：防止恶意或错误程序直接操作硬件资源

- 稳定性：内核统一管理资源，避免程序互相干扰

- 可控性：操作系统可以统一调度、审计和限制程序的行为

