## 📜 三次握手流程图
```text
客户端（Client）                                服务端（Server）

      SYN = 1, Seq = x
  ------------------------->       第一次握手：Client 发起连接请求

                            SYN = 1, ACK = 1, Seq = y, Ack = x+1
  <-------------------------       第二次握手：Server 同意连接请求并响应

      ACK = 1, Seq = x+1, Ack = y+1
  ------------------------->       第三次握手：Client 确认响应，连接建立

```

## 🔍 三次握手每一步详解
### ✅ 第一次握手：客户端发送 SYN
- 客户端向服务端发送一个 `SYN`（同步）标志位为 1 的 TCP 报文。

- 表示客户端请求建立连接。

- 同时随机生成一个初始序列号 `Seq = x`，用于后续数据传输的序列号标识。

- 此时客户端处于 `SYN_SEND` 状态。

### ✅ 第二次握手：服务端发送 SYN + ACK
- 服务端收到客户端的 `SYN` 报文后，表示能收到客户端发来的请求。

- 服务端也发送一个 `SYN` 报文（表示自己也要建立连接），并设置 `ACK` 标志位 表示对客户端请求的确认。

- 报文内容包括：

	- `Seq = y`（服务端自己的初始序列号）

	- `Ack = x+1`（确认客户端的序列号 + 1）

- 此时服务端处于 `SYN_RECEIVED` 状态。

### ✅ 第三次握手：客户端发送 ACK
- 客户端收到服务端的 `SYN` + `ACK` 报文后，确认连接建立。

- 向服务端发送一个 `ACK` 报文（确认连接成功）：

	- `Seq = x+1`

	- `Ack = y+1`（确认服务端的序列号）

- 此时客户端进入 `ESTABLISHED`（连接建立） 状态。

- 服务端接收到该 `ACK` 后，也进入 `ESTABLISHED` 状态，至此，连接建立完成。


## 📜 四次挥手流程图

```text
客户端（Client）                              服务端（Server）

  FIN = 1, Seq = u
  ------------------------->             第一次挥手（客户端主动关闭）

                            ACK = 1, Ack = u + 1
  <-------------------------             第二次挥手（服务端确认）

                            FIN = 1, Seq = v
  <-------------------------             第三次挥手（服务端也关闭）

  ACK = 1, Ack = v + 1
  ------------------------->             第四次挥手（客户端确认）

```

## 🔁 四次挥手每一步详解
### ✅ 第一次挥手：客户端发送 FIN
- 客户端调用 `close()` 方法，主动关闭连接。

- 发送一个 `FIN` 报文，表示“我不再发送数据了”。

- 进入 `FIN_WAIT_1` 状态。

### ✅ 第二次挥手：服务端回复 ACK
- 服务端收到 `FIN` 后，发送 `ACK` 报文。

- 表示“我收到了你关闭连接的请求”。

- 服务端进入 `CLOSE_WAIT `状态。

- 客户端进入 `FIN_WAIT_2` 状态。


⚠️ 此时连接还未关闭，服务端可能还有数据要发送。

### ✅ 第三次挥手：服务端发送 FIN
- 当服务端也没有要发送的数据后，调用 `close()`。

- 发送 `FIN` 报文，表示“我也发送完数据了，准备关闭连接”。

- 服务端进入 `LAST_ACK` 状态。

### ✅ 第四次挥手：客户端回复 ACK
- 客户端收到服务端的 `FIN` 报文，发送 `ACK` 确认。

- 然后进入 `TIME_WAIT` 状态，等待 2 倍最大报文段寿命（2MSL）。

- 服务端收到后直接进入 `CLOSED` 状态，连接完全关闭。

## 🔑 TCP 报文核心字段解释（SYN / ACK / Seq / Ack/ FIN）


### 🧩 1. `SYN`（Synchronize）

- **全称**：Synchronize
- **作用**：**同步序列号**，用于建立连接。
- **设置位置**：TCP 报文头的控制位中。
- **典型场景**：三次握手中的第一次和第二次握手。
- **说明**：
  - 表示“我想建立连接，并告诉你我的初始序列号（Seq）”。
  - SYN 报文会占用一个序号。

> ✅ `SYN = 1` 表示这是一个连接请求或响应。

---

### 🧩 2. `ACK`（Acknowledgment）

- **全称**：Acknowledgment
- **作用**：**确认应答**，用于确认接收到对方的数据。
- **设置位置**：TCP 报文头的控制位中。
- **典型场景**：
  - 三次握手的第 2、3 步
  - 四次挥手的第 2、4 步
  - 数据传输中每次都包含 ACK。
- **说明**：
  - 只有 `ACK = 1` 时，`Ack` 字段才有效。
  - 所有 TCP 报文从连接建立完成后都必须带 ACK。

> ✅ `ACK = 1` 表示“我已经收到你发来的数据/请求”。

---

### 🧩 3. `Seq`（Sequence Number）

- **全称**：Sequence Number（序列号）
- **作用**：标识本报文段中 **第一个字节的序号**。
- **使用目的**：用于数据重组、乱序处理、丢包检测。
- **说明**：
  - TCP 是面向字节流的，`Seq` 表示这一段数据在整个数据流中的起点。
  - 初始序列号是双方各自随机生成的一个数（ISN）。
  - 每个字节在 TCP 流中都有唯一序号。

> ✅ `Seq = x` 表示这一段数据是从第 `x` 个字节开始的。

---

### 🧩 4. `Ack`（Acknowledgment Number）

- **全称**：Acknowledgment Number（确认号）
- **作用**：告诉对方“我已经收到了你哪个序列号之前的数据”。
- **使用目的**：确认接收成功，指导下一次发送。
- **说明**：
  - `Ack = x` 表示“我期望你从第 `x` 个字节开始继续发”。
  - 所以 `Ack` 其实是“下一个希望收到的字节序号”。

> ✅ `Ack = x` 表示收到了对方发来的 `x - 1` 字节为止的全部数据。

---

### 🧩 5. `FIN`（Finish）

- **全称**：Finish
- **作用**：表示“我已经没有数据要发送了”，请求关闭连接。
- **所在位置**：TCP 报文头的控制位。
- **常见场景**：四次挥手的第 1 和第 3 步。
- **说明**：
  - 表示本端主动关闭发送方向（发送通道）。
  - FIN 报文会 **占用一个序列号**。

> ✅ `FIN = 1` 表示“我准备关闭连接（发送完毕）”。

---

### 🧠 快速对照表

| 字段名 | 类型     | 意义                             | 是否占用序号 | 常见场景           |
|--------|----------|----------------------------------|--------------|--------------------|
| SYN    | 标志位   | 请求建立连接，并同步初始序列号   | ✅ 是         | 三次握手           |
| ACK    | 标志位   | 表示确认号字段有效               | ❌ 否         | 握手、挥手、传输中 |
| Seq    | 字段     | 当前报文数据起始字节位置         | ✅ 是         | 所有数据报文       |
| Ack    | 字段     | 希望对方下次发送的字节序号       | ❌ 否         | 所有确认场景       |
| FIN    | 标志位   | 请求关闭连接，表示发送完成       | ✅ 是         | 四次挥手           |